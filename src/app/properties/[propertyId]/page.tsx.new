'use client';

import { useState, useEffect, use } from 'react';
import { useRouter } from 'next/navigation';
import Navigation from '@/components/Navigation';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { MapPin, Star, Calendar, Users, Coffee, Wifi, Car, CheckCircle2 } from 'lucide-react';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { normalizeDate, calculateNights, storeBookingSearch, getBookingSearch } from '@/lib/date-utils';

type RoomType = {
  id: string;
  name: string;
  description: string | null;
  capacity: number;
  basePrice: number;
  amenities: string[];
  isActive: boolean;
  availableRooms: number;
  totalRooms: number;
  photos: Array<{
    id: string;
    url: string;
    isMain: boolean;
  }>;
};

type Property = {
  id: string;
  name: string;
  description: string | null;
  address: string;
  city: string;
  state: string;
  zipCode: string;
  phone: string;
  email: string | null;
  amenities: string[];
  isActive: boolean;
  photos: Array<{
    id: string;
    url: string;
    isMain: boolean;
  }>;
  roomTypes: RoomType[];
};

type BookingDetails = {
  checkIn: string;
  checkOut: string;
  guests: number;
  roomTypeId: string;
  rooms: number;
};

export default function PropertyDetailsPage({ params }: { params: Promise<{ propertyId: string }> }) {
  const router = useRouter();
  const [property, setProperty] = useState<Property | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  
  // Use React.use() to unwrap the params promise
  const { propertyId } = use(params);
  
  const [bookingDetails, setBookingDetails] = useState<BookingDetails>({
    checkIn: new Date().toISOString().split('T')[0],
    checkOut: new Date(Date.now() + 86400000).toISOString().split('T')[0], // tomorrow
    guests: 1,
    roomTypeId: '',
    rooms: 1
  });
  
  const [selectedRoomType, setSelectedRoomType] = useState<RoomType | null>(null);
  const [showBookingForm, setShowBookingForm] = useState(false);
  const [isBooking, setIsBooking] = useState(false);
  const [bookingError, setBookingError] = useState('');
  const [bookingSuccess, setBookingSuccess] = useState(false);
  
  useEffect(() => {
    const fetchProperty = async () => {
      if (!propertyId) return;
      
      try {
        setLoading(true);
        
        // First try to get dates from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        let checkInParam = urlParams.get('checkIn');
        let checkOutParam = urlParams.get('checkOut');
        let guestsParam = urlParams.get('guests');
        
        // Clean the checkInParam of any cache busting parameters
        if (checkInParam && checkInParam.includes('?')) {
          checkInParam = checkInParam.split('?')[0];
          console.log(`Cleaned check-in param: ${checkInParam}`);
        }
        
        // Get stored search from sessionStorage if URL params aren't available
        if (!checkInParam || !checkOutParam) {
          try {
            const searchData = getBookingSearch();
            checkInParam = checkInParam || searchData.checkIn;
            checkOutParam = checkOutParam || searchData.checkOut;
            guestsParam = guestsParam || searchData.guests;
            console.log("Using dates from stored search:", { checkInParam, checkOutParam, guestsParam });
          } catch (e) {
            console.error("Error getting stored booking search:", e);
          }
        }
        
        // Normalize the check-in date
        if (checkInParam) {
          // Ensure it's a valid date in YYYY-MM-DD format using noon UTC to avoid timezone issues
          let checkInDate: Date;
          try {
            checkInDate = new Date(`${checkInParam}T12:00:00Z`);
            if (!isNaN(checkInDate.getTime())) {
              const formattedCheckIn = checkInDate.toISOString().split('T')[0];
              console.log(`Setting check-in date: ${formattedCheckIn} (from ${checkInParam})`);
              setBookingDetails(prev => ({...prev, checkIn: formattedCheckIn}));
            } else {
              console.warn(`Invalid check-in date detected: ${checkInParam}`);
              // Fallback to today's date if invalid
              const today = new Date();
              const formattedToday = today.toISOString().split('T')[0];
              setBookingDetails(prev => ({...prev, checkIn: formattedToday}));
            }
          } catch (error) {
            console.error("Error parsing check-in date:", error);
            // Fallback to today's date on error
            const today = new Date();
            const formattedToday = today.toISOString().split('T')[0];
            setBookingDetails(prev => ({...prev, checkIn: formattedToday}));
          }
        }
        
        // Normalize the check-out date
        if (checkOutParam) {
          // Ensure it's a valid date in YYYY-MM-DD format using noon UTC to avoid timezone issues
          let checkOutDate: Date;
          try {
            checkOutDate = new Date(`${checkOutParam}T12:00:00Z`);
            if (!isNaN(checkOutDate.getTime())) {
              const formattedCheckOut = checkOutDate.toISOString().split('T')[0];
              console.log(`Setting check-out date: ${formattedCheckOut} (from ${checkOutParam})`);
              setBookingDetails(prev => ({...prev, checkOut: formattedCheckOut}));
            } else {
              console.warn(`Invalid check-out date detected: ${checkOutParam}`);
              // Fallback to tomorrow's date if invalid
              const tomorrow = new Date();
              tomorrow.setDate(tomorrow.getDate() + 1);
              const formattedTomorrow = tomorrow.toISOString().split('T')[0];
              setBookingDetails(prev => ({...prev, checkOut: formattedTomorrow}));
            }
          } catch (error) {
            console.error("Error parsing check-out date:", error);
            // Fallback to tomorrow's date on error
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            const formattedTomorrow = tomorrow.toISOString().split('T')[0];
            setBookingDetails(prev => ({...prev, checkOut: formattedTomorrow}));
          }
        }
        
        // Handle guests parameter
        if (guestsParam) {
          try {
            const guestsValue = parseInt(guestsParam);
            if (!isNaN(guestsValue) && guestsValue > 0) {
              console.log(`Setting guests: ${guestsValue}`);
              setBookingDetails(prev => ({...prev, guests: guestsValue}));
            }
          } catch (error) {
            console.error("Error parsing guests parameter:", error);
          }
        }
        
        // Ensure we have clean YYYY-MM-DD formatted dates for consistency
        const cleanCheckIn = bookingDetails.checkIn.trim().match(/^\d{4}-\d{2}-\d{2}$/)
          ? bookingDetails.checkIn.trim()
          : new Date(`${bookingDetails.checkIn}T12:00:00Z`).toISOString().split('T')[0];
          
        const cleanCheckOut = bookingDetails.checkOut.trim().match(/^\d{4}-\d{2}-\d{2}$/)
          ? bookingDetails.checkOut.trim()
          : new Date(`${bookingDetails.checkOut}T12:00:00Z`).toISOString().split('T')[0];
        
        // Save the current booking details to sessionStorage for consistency
        const currentBookingDetails = {
          propertyId,
          checkIn: cleanCheckIn,
          checkOut: cleanCheckOut,
          guests: guestsParam ? parseInt(guestsParam) : bookingDetails.guests
        };
        
        // Save both currentBooking and lastSearch to maintain consistency across flows
        sessionStorage.setItem('currentBooking', JSON.stringify(currentBookingDetails));
        sessionStorage.setItem('lastSearch', JSON.stringify({
          propertyId,
          checkIn: cleanCheckIn,
          checkOut: cleanCheckOut,
          guests: currentBookingDetails.guests
        }));
        
        // Build API URL with date parameters to ensure we get date-specific availability
        const apiParams = new URLSearchParams();
        const timestamp = new Date().getTime();
        
        if (cleanCheckIn) apiParams.append('checkIn', cleanCheckIn);
        if (cleanCheckOut) apiParams.append('checkOut', cleanCheckOut);
        if (bookingDetails.guests) apiParams.append('guests', bookingDetails.guests.toString());
        apiParams.append('_t', timestamp.toString()); // Add cache busting
        
        const apiUrl = `/api/properties/${propertyId}?${apiParams.toString()}`;
        console.log(`Fetching property with date-specific availability: ${apiUrl}`);
        
        const response = await fetch(apiUrl, {
          // Add cache control headers
          headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0'
          }
        });
        
        if (!response.ok) {
          throw new Error('Failed to fetch property');
        }
        
        const data = await response.json();
        setProperty(data);
        console.log(`Property loaded with ${data.roomTypes?.length || 0} room types`);
        
        // If there are room types, select the first one by default
        if (data.roomTypes && data.roomTypes.length > 0) {
          setSelectedRoomType(data.roomTypes[0]);
          setBookingDetails(prev => ({
            ...prev,
            roomTypeId: data.roomTypes[0].id
          }));
          
          // Log availability for debugging
          data.roomTypes.forEach((rt: RoomType) => {
            console.log(`Room type: ${rt.name}, Available: ${rt.availableRooms}/${rt.totalRooms}`);
            console.log(`Calculated Available Rooms: ${(rt as any).calculatedAvailableRooms}`);
          });
        }
      } catch (err) {
        setError('Error loading property. Please try again.');
        console.error('Error fetching property:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchProperty();
  }, [propertyId]);

  const handleBookingDetailsChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setBookingDetails(prev => ({
      ...prev,
      [name]: name === 'guests' || name === 'rooms' ? parseInt(value) : value
    }));
  };

  const handleRoomTypeChange = (roomTypeId: string) => {
    const roomType = property?.roomTypes.find(rt => rt.id === roomTypeId);
    if (roomType) {
      setSelectedRoomType(roomType);
      setBookingDetails(prev => ({
        ...prev,
        roomTypeId: roomType.id
      }));
    }
  };

  const calculateTotalPrice = () => {
    if (!selectedRoomType || !bookingDetails.checkIn || !bookingDetails.checkOut) return 0;
    
    // Use our date utility function to normalize dates and calculate nights
    const normalizedCheckIn = normalizeDate(bookingDetails.checkIn);
    const normalizedCheckOut = normalizeDate(bookingDetails.checkOut, 1); // fallback to tomorrow if invalid
    
    // Get date objects for logging
    const checkIn = new Date(`${normalizedCheckIn}T12:00:00Z`);
    const checkOut = new Date(`${normalizedCheckOut}T12:00:00Z`);
    
    // Calculate nights using our utility function
    const nights = calculateNights(normalizedCheckIn, normalizedCheckOut);
    
    console.log(`Calculating price: ${nights} nights × ${selectedRoomType.basePrice} × ${bookingDetails.rooms} rooms`);
    console.log(`Date details for price calculation: checkIn=${checkIn.toISOString()}, checkOut=${checkOut.toISOString()}`);
    console.log(`Normalized dates: checkIn=${normalizedCheckIn}, checkOut=${normalizedCheckOut}`);
    
    return selectedRoomType.basePrice * nights * bookingDetails.rooms;
  };

  const refreshAvailability = () => {
    // Force refresh with current dates
    const timestamp = new Date().getTime();
    const params = new URLSearchParams();
    
    // Use our date utility function for consistent normalization
    const cleanCheckIn = normalizeDate(bookingDetails.checkIn);
    const cleanCheckOut = normalizeDate(bookingDetails.checkOut, 1);
    
    // Add parameters properly formatted
    params.append('checkIn', cleanCheckIn);
    params.append('checkOut', cleanCheckOut);
    params.append('guests', bookingDetails.guests.toString());
    
    // Add timestamp as a separate parameter for cache busting
    params.append('_t', timestamp.toString());
    
    // Use our utility to store search parameters consistently
    storeBookingSearch({
      checkIn: cleanCheckIn,
      checkOut: cleanCheckOut,
      guests: bookingDetails.guests,
      propertyId
    });
    
    console.log(`Refreshing availability for dates: ${cleanCheckIn} to ${cleanCheckOut}`);
    
    // Use replace to force a full page reload
    router.replace(`/properties/${propertyId}?${params.toString()}`);
  };
  
  const handleBookNow = async () => {
    try {
      setIsBooking(true);
      setBookingError('');
      
      // Check if user is logged in
      const authResponse = await fetch('/api/auth/session');
      const authData = await authResponse.json();
      
      if (!authData.user) {
        // Save booking details to session storage and redirect to login
        sessionStorage.setItem('pendingBooking', JSON.stringify({
          propertyId: propertyId,
          ...bookingDetails
        }));
        
        router.push('/login?redirect=/properties/' + propertyId);
        return;
      }
      
      // Format dates consistently as YYYY-MM-DD for the API using our utility
      const formattedCheckIn = normalizeDate(bookingDetails.checkIn);
      const formattedCheckOut = normalizeDate(bookingDetails.checkOut, 1); // fallback to tomorrow if invalid
        
      console.log('Creating booking with dates:', {
        original: {
          checkIn: bookingDetails.checkIn,
          checkOut: bookingDetails.checkOut
        },
        formatted: {
          checkIn: formattedCheckIn,
          checkOut: formattedCheckOut
        }
      });
      
      // Store the final booking details for consistency across the flow
      storeBookingSearch({
        checkIn: formattedCheckIn,
        checkOut: formattedCheckOut,
        guests: bookingDetails.guests,
        propertyId
      });
      
      // User is logged in, proceed with booking
      const response = await fetch('/api/bookings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          propertyId: propertyId,
          roomTypeId: bookingDetails.roomTypeId,
          checkIn: formattedCheckIn,
          checkOut: formattedCheckOut,
          guests: bookingDetails.guests,
          rooms: bookingDetails.rooms,
          totalPrice: calculateTotalPrice()
        }),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create booking');
      }
      
      setBookingSuccess(true);
      
      // Redirect to bookings page after 2 seconds
      setTimeout(() => {
        router.push('/dashboard');
      }, 2000);
      
    } catch (err: Error | unknown) {
      console.error('Error creating booking:', err);
      setBookingError(err instanceof Error ? err.message : 'An error occurred during booking. Please try again.');
    } finally {
      setIsBooking(false);
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50">
        <Navigation />
        <div className="container mx-auto px-4 py-8 flex justify-center items-center min-h-[70vh]">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
        </div>
      </div>
    );
  }

  if (error || !property) {
    return (
      <div className="min-h-screen bg-gray-50">
        <Navigation />
        <div className="container mx-auto px-4 py-8">
          <div className="text-center py-12">
            <h3 className="text-lg font-medium text-red-600 mb-2">{error || 'Property not found'}</h3>
            <Button onClick={() => router.push('/properties')}>Back to Properties</Button>
          </div>
        </div>
      </div>
    );
  }

  const mainPhoto = property.photos.find(p => p.isMain)?.url || property.photos[0]?.url;

  return (
    <div className="min-h-screen bg-gray-50">
      <Navigation />
      
      <div className="container mx-auto px-4 py-8">
        {/* Property Header */}
        <div className="mb-8">
          <div className="flex flex-wrap items-center justify-between mb-4">
            <div>
              <h1 className="text-3xl font-bold text-gray-900 mb-2">{property.name}</h1>
              <div className="flex items-center space-x-2">
                <MapPin className="h-4 w-4 text-gray-500" />
                <span className="text-gray-600">
                  {property.address}, {property.city}, {property.state} {property.zipCode}
                </span>
              </div>
            </div>
            <div className="flex items-center mt-2 lg:mt-0">
              <div className="flex items-center bg-blue-50 px-3 py-1 rounded-lg">
                <Star className="h-5 w-5 text-yellow-500 fill-current" />
                <span className="ml-1 font-semibold text-gray-800">4.8</span>
                <span className="ml-1 text-gray-500">(42 reviews)</span>
              </div>
            </div>
          </div>
          
          {/* Property Image */}
          {mainPhoto && (
            <div className="rounded-xl overflow-hidden aspect-[21/9] relative mb-6">
              <img 
                src={mainPhoto} 
                alt={property.name} 
                className="w-full h-full object-cover"
              />
            </div>
          )}
          
          {/* Property Info */}
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
            {/* Left Column: Property Details */}
            <div className="lg:col-span-2">
              <div className="bg-white p-6 rounded-xl shadow-sm mb-6">
                <h2 className="text-xl font-bold mb-4">About this property</h2>
                <p className="text-gray-600 mb-6">
                  {property.description || 'No description provided for this property.'}
                </p>
                
                <h3 className="font-bold mb-2 text-lg">Amenities</h3>
                <div className="grid grid-cols-2 gap-2">
                  {property.amenities.map((amenity, i) => (
                    <div key={i} className="flex items-center">
                      <CheckCircle2 className="h-4 w-4 text-green-500 mr-2" />
                      <span>{amenity}</span>
                    </div>
                  ))}
                  {property.amenities.length === 0 && (
                    <span className="text-gray-500">No amenities listed</span>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
        
        {/* Room Types */}
        <div className="mb-8">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-2xl font-bold">Available Rooms</h2>
            
            <div className="flex items-center space-x-2">
              <div className="text-sm text-gray-500">
                {bookingDetails.checkIn && bookingDetails.checkOut && (
                  <span>
                    For {new Date(bookingDetails.checkIn).toLocaleDateString('en-US', {month: 'short', day: 'numeric'})} - {new Date(bookingDetails.checkOut).toLocaleDateString('en-US', {month: 'short', day: 'numeric'})}
                  </span>
                )}
              </div>
              
              <Button 
                variant="outline" 
                size="sm"
                className="flex items-center space-x-1 text-blue-600 border-blue-200 hover:bg-blue-50"
                onClick={refreshAvailability}
              >
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="animate-spin duration-1000">
                  <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"></path>
                </svg>
                <span>Refresh Availability</span>
              </Button>
            </div>
          </div>
          
          {property.roomTypes.length === 0 ? (
            <div className="bg-white p-6 rounded-lg shadow-sm text-center">
              <p className="text-gray-500">No rooms available at this property.</p>
            </div>
          ) : (
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              {property.roomTypes.map(roomType => {
                const roomPhoto = roomType.photos.find(p => p.isMain)?.url || 
                                 roomType.photos[0]?.url || 
                                 mainPhoto;
                                 
                // Use calculatedAvailableRooms if available (from date-specific check)
                // Otherwise fall back to the standard availableRooms
                const availableRooms = (roomType as any).calculatedAvailableRooms !== undefined 
                  ? (roomType as any).calculatedAvailableRooms 
                  : roomType.availableRooms;
                  
                const isAvailable = (availableRooms > 0) && roomType.isActive;
                
                console.log(`Rendering room type ${roomType.name}: isAvailable=${isAvailable}, availableRooms=${availableRooms}, calculatedAvailable=${(roomType as any).calculatedAvailableRooms}`);
                
                return (
                  <Card 
                    key={roomType.id}
                    className={`overflow-hidden hover:shadow-md transition-shadow ${
                      selectedRoomType?.id === roomType.id ? 'ring-2 ring-blue-500' : ''
                    }`}
                    onClick={() => isAvailable && handleRoomTypeChange(roomType.id)}
                  >
                    <div className="aspect-video relative overflow-hidden">
                      {roomPhoto ? (
                        <img
                          src={roomPhoto}
                          alt={roomType.name}
                          className="w-full h-full object-cover"
                        />
                      ) : (
                        <div className="w-full h-full bg-gray-200 flex items-center justify-center">
                          <span className="text-gray-400">No image available</span>
                        </div>
                      )}
                      
                      {!isAvailable && (
                        <div className="absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center">
                          <Badge variant="destructive" className="text-lg py-1 px-3">
                            Not Available
                          </Badge>
                        </div>
                      )}
                    </div>
                    
                    <CardHeader>
                      <div className="flex items-start justify-between">
                        <CardTitle>{roomType.name}</CardTitle>
                        <div className="text-xl font-bold text-blue-600">${roomType.basePrice}<span className="text-sm font-normal text-gray-500">/night</span></div>
                      </div>
                      <CardDescription>
                        Up to {roomType.capacity} guests
                      </CardDescription>
                      <div className="mt-1 text-sm text-muted-foreground flex flex-col space-y-1">
                        <div className="flex items-center">
                          <span className={`font-medium ${availableRooms > 0 ? 'text-green-600' : 'text-red-600'}`}>
                            {availableRooms} {availableRooms === 1 ? 'room' : 'rooms'} available
                          </span>
                          
                          {bookingDetails.checkIn && bookingDetails.checkOut && (
                            <span className="ml-2 text-xs text-gray-500">
                              for {new Date(bookingDetails.checkIn).toLocaleDateString()} - {new Date(bookingDetails.checkOut).toLocaleDateString()}
                            </span>
                          )}
                        </div>
                        
                        {availableRooms > 0 && bookingDetails.checkIn && bookingDetails.checkOut && (
                          <div className="text-xs text-green-700 flex items-center mt-1">
                            <CheckCircle2 className="h-3 w-3 mr-1" /> 
                            Available for your selected dates
                          </div>
                        )}
                        
                        {roomType.totalRooms > 0 && (
                          <div className="text-xs text-gray-500 mt-1">
                            {availableRooms}/{roomType.totalRooms} total rooms
                          </div>
                        )}
                      </div>
                    </CardHeader>
                    
                    <CardContent>
                      <p className="text-sm text-gray-600 mb-4">
                        {roomType.description || 'Comfortable accommodation with standard amenities.'}
                      </p>
                      
                      <div className="flex flex-wrap gap-2 mb-4">
                        {roomType.amenities.map((amenity, i) => (
                          <Badge key={i} variant="outline" className="bg-blue-50">
                            {amenity}
                          </Badge>
                        ))}
                      </div>
                      
                      <div className="mt-4">
                        <Button 
                          className="w-full"
                          disabled={!isAvailable}
                          onClick={() => {
                            setSelectedRoomType(roomType);
                            setBookingDetails(prev => ({
                              ...prev,
                              roomTypeId: roomType.id
                            }));
                            setShowBookingForm(true);
                          }}
                        >
                          {isAvailable ? 'Select Room' : 'Not Available'}
                        </Button>
                      </div>
                    </CardContent>
                  </Card>
                );
              })}
            </div>
          )}
        </div>
        
        {/* Booking Form */}
        {showBookingForm && selectedRoomType && (
          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-2xl font-bold mb-4">Book Your Stay</h2>
            
            {bookingSuccess ? (
              <div className="p-4 bg-green-50 border border-green-200 rounded-md text-center">
                <CheckCircle2 className="h-12 w-12 text-green-500 mx-auto mb-2" />
                <h3 className="text-lg font-medium text-green-800 mb-2">Booking Confirmed!</h3>
                <p className="text-green-700">
                  Your booking has been successfully created. Redirecting to your dashboard...
                </p>
              </div>
            ) : (
              <>
                {bookingError && (
                  <div className="p-4 mb-4 bg-red-50 border border-red-200 rounded-md">
                    <p className="text-red-700">{bookingError}</p>
                  </div>
                )}
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                  <div>
                    <h3 className="font-medium mb-2">Booking Details</h3>
                    <div className="space-y-4">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Check-in Date</label>
                        <Input
                          type="date"
                          name="checkIn"
                          value={bookingDetails.checkIn}
                          onChange={handleBookingDetailsChange}
                          min={new Date().toISOString().split('T')[0]}
                          className="w-full"
                        />
                      </div>
                      
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Check-out Date</label>
                        <Input
                          type="date"
                          name="checkOut"
                          value={bookingDetails.checkOut}
                          onChange={handleBookingDetailsChange}
                          min={bookingDetails.checkIn}
                          className="w-full"
                        />
                      </div>
                      
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Guests</label>
                        <select
                          name="guests"
                          value={bookingDetails.guests}
                          onChange={handleBookingDetailsChange}
                          className="w-full border border-gray-300 rounded-md p-2"
                        >
                          {Array.from({ length: selectedRoomType.capacity }, (_, i) => i + 1).map((num) => (
                            <option key={num} value={num}>
                              {num} {num === 1 ? 'Guest' : 'Guests'}
                            </option>
                          ))}
                        </select>
                      </div>
                      
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Number of Rooms</label>
                        <select
                          name="rooms"
                          value={bookingDetails.rooms}
                          onChange={handleBookingDetailsChange}
                          className="w-full border border-gray-300 rounded-md p-2"
                        >
                          {Array.from(
                            { length: Math.min(5, (roomType as any).calculatedAvailableRooms || selectedRoomType.availableRooms) }, 
                            (_, i) => i + 1
                          ).map((num) => (
                            <option key={num} value={num}>
                              {num} {num === 1 ? 'Room' : 'Rooms'}
                            </option>
                          ))}
                        </select>
                      </div>
                    </div>
                  </div>
                  
                  <div>
                    <h3 className="font-medium mb-2">Booking Summary</h3>
                    <div className="bg-gray-50 p-4 rounded-md">
                      <div className="mb-4">
                        <h4 className="font-medium">{selectedRoomType.name}</h4>
                        <p className="text-sm text-gray-600">
                          {selectedRoomType.description || 'Comfortable accommodation with standard amenities.'}
                        </p>
                      </div>
                      
                      <div className="space-y-2 text-sm">
                        <div className="flex justify-between">
                          <span>Room Rate:</span>
                          <span>${selectedRoomType.basePrice} per night</span>
                        </div>
                        
                        <div className="flex justify-between">
                          <span>Number of Nights:</span>
                          <span>{calculateNights(bookingDetails.checkIn, bookingDetails.checkOut)}</span>
                        </div>
                        
                        <div className="flex justify-between">
                          <span>Number of Rooms:</span>
                          <span>{bookingDetails.rooms}</span>
                        </div>
                        
                        <div className="border-t pt-2 mt-2 flex justify-between font-bold">
                          <span>Total Price:</span>
                          <span>${calculateTotalPrice()}</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                
                <div className="flex justify-end">
                  <Button
                    variant="outline"
                    className="mr-2"
                    onClick={() => setShowBookingForm(false)}
                  >
                    Cancel
                  </Button>
                  <Button
                    onClick={handleBookNow}
                    disabled={isBooking}
                  >
                    {isBooking ? 'Processing...' : 'Book Now'}
                  </Button>
                </div>
              </>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
